name: 'Pre-Commit tests'

# Controls when the workflow will run
on:
  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:
    inputs:
      default_branch:
        description: 'The SHA of the default branch'
        required: true
        type: string
  push:
    branches:
      - $GITHUB_BASE_REF
        #if: github.ref == format('refs/heads/{0}', github.event.repository.default_branch)
    paths:
       - '.github/workflows/pre-commit.yml'
       - '.pre-commit-config.yaml'
  pull_request:
    paths:
       - '.github/workflows/pre-commit.yml'
       - '.pre-commit-config.yaml'

# from the example here:
# https://docs.github.com/en/actions/examples/using-scripts-to-test-your-code-on-a-runner#example-workflow
permissions:
  contents: read
  pull-requests: read
concurrency:
  group: '${{ github.workflow }} @ ${{ github.event.pull_request.head.label || github.head_ref || github.ref }}'
  cancel-in-progress: true

jobs:
  get-changed-files:
    runs-on: ubuntu-latest
    outputs:
      BASE_REF: ${{ steps.export_base_ref.outputs.BASE_REF }}
      CHANGED_FILES: ${{ steps.changed_files.outputs.CHANGED_FILES }}
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 2

      - name: Export BASE_REF
        id: export_base_ref
        run: |
          if [[ -n "${{ github.event.pull_request.base.sha }}" ]]; then
            # use GHA's variable
            BASE_REF=${{ github.event.pull_request.base.sha }}
          elif [[ -n "${{ inputs.default_branch }}" ]]; then
            # trust user input for default branch SHA
            BASE_REF=${{ inputs.default_branch }}
          else
            # assume 'origin/HEAD' can be referenced
            BASE_REF='origin/HEAD'
          fi
          echo "BASE_REF=${BASE_REF}" >> $GITHUB_ENV # needed for the changed_files step
          echo "BASE_REF=${BASE_REF}" >> $GITHUB_OUTPUT

      - name: Generate Changed Files List
        id: changed_files
        run: |
          #          readarray -t files < <(git diff --name-only $BASE_REF..HEAD)
          #          {
          #            echo "CHANGED_FILES<<EOF"
          #            echo ${files[*]}
          #            echo EOF
          #          }  >> $GITHUB_OUTPUT
          files=($(git diff --name-only $BASE_REF..HEAD))
          echo "CHANGED_FILES=${files[*]}" >> $GITHUB_OUTPUT
        shell: bash

  pre-commit:
    runs-on: ubuntu-latest
    needs: [get-changed-files]
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 2

      - name: Install go
        # 'nektos/act' requires this conditional step due to the following
        # issue when running 'shfmt' from pre-commit-config.yaml:
        # package mvdan.cc/sh/v3/cmd/shfmt@v3.7.0: can only use path@version syntax with 'go get'
        # https://www.reddit.com/r/golang/comments/n628db/go_install_fails_with_can_only_use_pathversion/
        if: ${{ env.ACT }}
        uses: actions/setup-go@v4
        with:
          go-version: '>=1.21'
          check-latest: true

      - uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - uses: pre-commit/action@v3.0.0
        with:
          # this should run the pre-commit hooks only on the files changed between the default branch and the one in the PR
          extra_args: --from-ref ${{ needs.get-changed-files.outputs.BASE_REF }} --to-ref HEAD


  # this only checks if the README had been generated; it can't itself commit
  # the generated file
  check-readme:
    runs-on: ubuntu-latest
    needs: [get-changed-files]
    if: contains(needs.get-changed-files.outputs.CHANGED_FILES, 'README.md.tpl')
    steps:
      - uses: actions/checkout@v3

      - name: Install envsubst
        # this is required when using nektos/act due to this sort of issue with
        # act's ubuntu:latest image (it's still on 20.04):
        if: ${{ env.ACT }}
        run: |
          declare -A pkgs_to_install=(
          [envsubst]=gettext-base
          [column]=bsdextrautils
          )
          for pkg in ${!pkgs_to_check[*]}; do
             which "${pkg}" &>/dev/null && unset pkgs_to_install["${pkg}"]
          done
          apt-get update &&
          apt-get install ${pkgs_to_install[*]}

      - name: Ensure Documentation Was Generated
        run: |
          README_FILENAME="README.md"
          if [[ -s "${README_FILENAME}" ]]; then
            ORIG_CHECKSUM="$(md5sum "${README_FILENAME}")"
            mv -v "${README_FILENAME}" "${README_FILENAME}.orig"
            make readme
            NEW_CHECKSUM="$(md5sum "${README_FILENAME}")"
            [[ "${ORIG_CHECKSUM}" == "${NEW_CHECKSUM}" ]] || {
              echo "error: ${README_FILENAME} was not generated"
              echo
              echo "Generate the documentation using this command, then commit and push:"
              echo
              echo "    make readme"
              echo
              exit 1
            }
          else
            echo "error: ${README_FILENAME} doesn't exist or is empty"
            exit 1
          fi

  dump-env:
    # most of this inspired by:
    # https://stackoverflow.com/questions/67503656/echo-github-action-environment-variables/72920652#72920652
    #
    # unfortunately, a matrix doesn't seem to work properly without hacky
    # workarounds due to expression evaluation

    if: github.event.inputs.DEBUG == 'true' || github.event.inputs.DEBUG == 1 || (always() && contains(needs.*.result, 'failure'))
    needs:
      - get-changed-files
      - pre-commit
      - check-readme
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - run: echo "BASE_REF = '${{ needs.get-changed-files.outputs.BASE_REF }}'"
      - run: echo "CHANGED_FILES = '${{ needs.get-changed-files.outputs.CHANGED_FILES }}'"

      - name: Git log
        run: git --no-pager log --graph -30 --abbrev-commit --decorate --date=relative --color --format=format:'%C(bold blue)%h%C(reset) - %C(bold yellow)(%ar)%C(reset) %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(auto)%d%C(reset)' --all -30

      - name: Dump 'env' context
        run: echo '${{ toJson(env) }}'

      - name: Dump 'vars' context
        run: echo '${{ toJson(vars) }}'

      - name: Dump 'secrets' context
        run: echo '${{ toJson(secrets) }}'

      - name: Dump 'needs' context
        run: echo '${{ toJson(needs) }}'

      - name: Dump 'inputs' context
        run: echo '${{ toJson(inputs) }}'

      - name: Dump GitHub context
        run: echo '${{ toJson(github) }}'

      - name: Dump job context
        run: echo '${{ toJson(job) }}'

      - name: Dump steps context
        run: echo '${{ toJson(steps) }}'

      - name: Dump runner context
        run: echo '${{ toJson(runner) }}'

      - name: Dump strategy context
        run: echo '${{ toJson(strategy) }}'

      - name: Dump matrix context
        run: echo '${{ toJson(matrix) }}'

      - name: Show default environment variables
        run: |
          echo "The job_id is: $GITHUB_JOB"   # reference the default environment variables
          echo "The id of this action is: $GITHUB_ACTION"   # reference the default environment variables
          echo "The run id is: $GITHUB_RUN_ID"
          echo "The GitHub Actor's username is: $GITHUB_ACTOR"
          echo "GitHub SHA: $GITHUB_SHA"
